# This script defines a class for writing bitstreams to a file.
import os, sys

def hex_to_little_endian_bits(hex_val, num_bytes=2):

    
    # 1. Ensure the input is an integer
    if isinstance(hex_val, str):
        try:
            value = int(hex_val, 16)
        except ValueError:
            return "Error: Invalid hexadecimal string"
    else:
        value = int(hex_val)

    # 2. Convert the integer to a byte string in "little" endian order
    try:
        # 'little' means the least significant byte comes first
        b = value.to_bytes(num_bytes, 'little')
    except OverflowError:
        return f"Error: {value} is too large to fit in {num_bytes} bytes."
    
    # 3. Format each byte into two 4-bit (nibble) strings
    bit_chunks = []
    for byte in b:
        # Format the byte as an 8-bit binary string, padding with 0s
        bin_str = f'{byte:08b}'
        
        # Split the 8-bit string into two 4-bit nibbles
        nibble1 = bin_str[0:8]

        
        # Add the nibbles to our list
        bit_chunks.extend([nibble1])
        
    # 4. Join all the nibbles with a space
    return ' '.join(bit_chunks)




class BitStream:
    """
    A class to write a stream of bits to a file in Big Endian order.
    Big Endian means that the most significant bit (MSB) is processed first.
    """

    def __init__(self, file_path):
        """
        Initializes the BitStream.
        
        Args:
            file_path (str): The path to the output file.
        """
        self.file_path = file_path
        self.file = None
        self.buffer = 0
        self.bit_count = 0

    def __enter__(self):
        """
        Opens the file for writing when entering a 'with' block.
        """
        self.file = open(self.file_path, 'wb')
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        """
        Flushes any remaining bits and closes the file when exiting a 'with' block.
        """
        self.flush()
        if self.file:
            self.file.close()

    def write_bits(self, bit_string):
        """
        Writes a string of bits to the stream.
        
        Args:
            bit_string (str): A string containing only '0's and '1's.
        """
        for bit in bit_string:
            if bit not in '01':
                #raise ValueError("bit_string can only contain '0' or '1'")
                continue;
            
            # Shift the buffer to the left to make room for the new bit
            self.buffer <<= 1
            if bit == '1':
                # Set the least significant bit
                self.buffer |= 1
            
            self.bit_count += 1
            
            # If the buffer is full (8 bits), write it to the file
            if self.bit_count == 8:
                self._write_byte()

    def write_integer(self, value, num_bits):
        """
        Converts an integer to a bit string and writes it to the stream.

        Args:
            value (int): The integer value to write.
            num_bits (int): The number of bits to represent the integer.
        """
        if value >= (1 << num_bits):
            raise ValueError(f"Value {value} cannot be represented with {num_bits} bits.")
        
        # Convert integer to binary string, remove '0b' prefix, and pad with zeros
        bit_string = bin(value)[2:].zfill(num_bits)
        self.write_bits(bit_string)

    def _write_byte(self):
        """
        Writes the current buffer as a single byte to the file and resets it.
        """
        if self.file:
            self.file.write(self.buffer.to_bytes(1, byteorder='big'))
        self.buffer = 0
        self.bit_count = 0
        
    def flush(self):
        """
        Writes any remaining bits in the buffer to the file, padding with zeros.
        This is necessary to ensure all data is written, even if it doesn't
        form a complete byte.
        """
        if self.bit_count > 0:
            # Pad the last byte with '0's on the right (least significant side)
            padding_needed = 8 - self.bit_count
            self.buffer <<= padding_needed
            self._write_byte()


# --- Demonstration of the BitStream Class ---
if __name__ == "__main__":
    output_filename = "output.bin"
    
    # The original bit series
    bits_to_write = "1111100000000000000"

    print("--- Using BitStream class ---")
    try:
        with BitStream(output_filename) as bs:
            bs.write_bits(bits_to_write)
        
        file_size = os.path.getsize(output_filename)
        print(f"Successfully wrote bitstream to '{output_filename}' ({file_size} bytes)")
        
        # You can inspect 'output.bin' with a hex editor. The bytes should be:
        # 11111000 -> 0xF8
        # 00000000 -> 0x00
        # 00000000 -> 0x00

    except (IOError, ValueError) as e:
        print(f"An error occurred: {e}")

    print("\n--- Example writing integers ---")
    integer_filename = "integers.bin"
    try:
        with BitStream(integer_filename) as bs:
            # Recreate the same bitstream by writing integers#0x85178
            bs.write_bits("00000"); #04 config
            #bs.write_bits("11");  #0c
            
            bs.write_bits("11011"); # payload_id
            bs.write_bits("00001"); #payload bits
            bs.write_bits("0010 1000 0"); #70 bytes
            for i in range(0, 0x28):
            	bs.write_bits("0000 0000");
            bs.write_bits("11011"); # payload_id (5 added for alignment)
            bs.write_bits("01 0000 0000 0000 00 0 0"); #payload bits
            bs.write_bits("0000 1000 0"); #2 bytes
            print(bs.bit_count)
           #0xcc2c
            bs.write_bits("0111 1000 0101 0110 0111 1000 0101 0110 0111 1000 0101 0110 0111 1000 0101 0110");
           # bs.write_bits("00000 00000000000000000000000000000000000");
            
         #   for i in range(0, 9354): #1720
        #    	bs.write_bits("11011");
         #   	bs.write_bits("00001");
          #  	bs.write_bits("000000000");
      #      bs.write_bits("11001");
       #     bs.write_bits("00001");
        #    bs.write_bits("1111 1110 1 1111 1110 1 1111 1110 1 1111 1110 1 1111 1110 1 1111 1110 1 1111 1110 1 1111 1110 0");
         #   bs.write_bits("00000 00000000000000000000000000000000000"); #final 0 payload to stop parsing
        file_size = os.path.getsize(integer_filename)
        print(f"Successfully wrote integers as a bitstream to '{integer_filename}' ({file_size} bytes)")


    except (IOError, ValueError) as e:
        print(f"An error occurred: {e}")


